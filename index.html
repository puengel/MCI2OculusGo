<html>
  <head>
    <script src="Assets/dist/aframe-master.min.js"></script>
    <script src="Assets/dist/aframe-environment-component.min.js"></script>
    <script src="Assets/src/components/oculus-go-controls.js"></script>
    <script>
      AFRAME.registerComponent("rcam", {
        init: function() {
          let el = this.el;

          el.addEventListener("enter-vr", function(event) {
            let camera = document.querySelector("a-camera");
            let position = camera.getAttribute("position");
            position.y = 2;
            camera.setAttribute("position", position);
          });
        }
      });

      //see moveToThumb component for documentation
      AFRAME.registerComponent("camera-movement", {
        init: function() {
          let self = this;
          let data = this.data;
          let el = this.el;
          this.data.moving = false;
          let moving = this.data.moving;

          el.addEventListener("trackpaddown", function(event) {
            self.data.moving = true;
          });

          el.addEventListener("trackpadup", function(event) {
            self.data.moving = false;
          });
        },

        tick: function() {
          if (this.data.moving) {
            let usedHand = navigator.getGamepads().item(0).hand;
            let hands = document.querySelectorAll("[raycaster]");
            let hand = null;
            if (usedHand == "left") {
              hand = hands[0];
            }
            if (usedHand == "right") {
              hand = hands[1];
            }

            let dir = hand.object3D.getWorldDirection();
            let wrapper = document.querySelector("#camera-wrapper");
            let pad = navigator.getGamepads().item(0);
            let axes = pad.axes;
            let pos = wrapper.getAttribute("position");

            let vz = 0;
            let vx = 0;

            let deadzone = 0.3;

            if (axes[1] > deadzone) {
              vz = 1;
            }

            if (axes[1] < -deadzone) {
              vz = -1;
            }

            if (axes[0] > deadzone) {
              vx = 1;
            }

            if (axes[0] < -deadzone) {
              vx = -1;
            }

            pos.x -= dir.z * 0.1 * -vx - dir.x * 0.1 * vz;
            pos.z -= dir.x * 0.1 * vx + dir.z * 0.1 * -vz;

            wrapper.setAttribute("position", pos);
          }
        }
      });

      //add 'grabbableobject' component, which defines if a component can be grabbed
      AFRAME.registerComponent("grabbableobject", {
        //called when component is applied to entitiy
        init: function() {
          var data = this.data;
          var el = this.el;

          //add mousedown event (click on OculusGO trigger)
          el.addEventListener("mousedown", function() {
            //set 'grabbed' attribute on element
            el.setAttribute("grabbed", null); //null must be set, since set Attribute requires 2 Arguments!
          });

          //add mouseup event (release clicked OculusGO trigger)
          el.addEventListener("mouseup", function() {
            //remove 'grabbed' attribute on element
            el.removeAttribute("grabbed");
          });
        }
      });

      //add 'grabbed' component which is applied to a grabbable element on click
      AFRAME.registerComponent("grabbed", {
        schema: {
          distance: { default: 1 } //used to preserve the distance between controller and moveable object
        },

        //called when component is applied to entitiy
        init: function() {
          let el = this.el;
          let data = this.data;

          //get oculusGO controller
          let hands = document.querySelectorAll("[raycaster]");
          let usedHand = navigator.getGamepads().item(0).hand;
          let hand = null;
          if (usedHand == "left") {
            hand = hands[0];
          }
          if (usedHand == "right") {
            hand = hands[1];
          }

          //calculate distance between controller and grabbed object
          let posRef = hand.object3D.getWorldPosition();
          let posObj = el.getAttribute("position");
          let distance = Math.sqrt(
            Math.pow(posRef.x - posObj.x, 2) +
              Math.pow(posRef.y - posObj.y, 2) +
              Math.pow(posRef.z - posObj.z, 2)
          );

          //overwrite distance in schema
          data.distance = distance;

          el.addEventListener("trackpadchanged", function() {
            el.setAttribute("color", "green");
            let dir = hand.object3D.getWorldDirection();
            let pad = navigator.getGamepads().item(0);
            let axes = pad.axes;
            let pos = wrapper.getAttribute("position");
            if (pos.y > 0) {
              data.distance += 1;
            }
            if (pos.y > 0) {
              data.distance -= 1;
            }
          });
        },

        //called once every frame
        tick: function() {
          let el = this.el;
          let data = this.data;

          //get oculusGO controller
          let hands = document.querySelectorAll("[raycaster]");
          let usedHand = navigator.getGamepads().item(0).hand;
          if (usedHand == "left") {
            hand = hands[0];
          }
          if (usedHand == "right") {
            hand = hands[1];
          }

          //get rotation and world position of controller
          let rot = hand.object3D.getWorldDirection();
          let posRef = hand.object3D.getWorldPosition();

          let scale = el.getAttribute("scale");

          //update new object position
          el.setAttribute("position", {
            x: posRef.x - rot.x * data.distance,
            y:
              posRef.y - rot.y * data.distance >= scale.y / 2
                ? posRef.y - rot.y * data.distance
                : scale.y / 2,
            z: posRef.z - rot.z * data.distance
          });
        }
      });
    </script>
  </head>

  <body>
    <a-scene rcam>
      <!-- generate 'player' camera -->
      <a-entity id="camera-wrapper" position="0 0 0">
        <a-camera id="camera" position="0 2 0"></a-camera>

        <a-entity
          camera-movement
          id="leftHand"
          laser-controls="hand: left"
          raycaster="objects: .collidable"
          line="color: #118A7E"
        ></a-entity>
        <a-entity
          camera-movement
          id="rightHand"
          laser-controls="hand: right"
          raycaster="objects: .collidable"
          line="color: #118A7E"
        ></a-entity>
      </a-entity>

      <!-- generate forest environment -->
      <a-entity environment="preset: forest; playArea: 1000000; dressingAmount: 500; dressingScale: 5; "></a-entity>

      <!-- generate grabbable box -->
    </a-scene>
    <script>
      //create the dynamic elements
      var urlParams = new URLSearchParams(location.search);
      let size = urlParams.get('size');
      console.log(size)

      let y_scale = 1.2;
      let xz_scale = 0.5;
      let t1_x = -10
      let t1_z = -10

      let t2_x = 0
      let t2_z = -Math.sqrt(200)

      let t3_x = 10
      let t3_z = -10

      let scene = document.querySelector('a-scene');
      let newBlock = document.createElement('a-box');
      newBlock.setAttribute('class', 'collidable')
      newBlock.setAttribute('color', 'black')
      newBlock.setAttribute('position', `${t1_x} 0 ${t1_z}`)
      let xz = size * 2 * xz_scale + xz_scale * 2
      newBlock.setAttribute('scale', `${xz} ${y_scale} ${xz}`)
      scene.appendChild(newBlock);

      newBlock = document.createElement('a-box');
      newBlock.setAttribute('class', 'collidable')
      newBlock.setAttribute('color', 'black')
      newBlock.setAttribute('position', `${t2_x} 0 ${t2_z}`)
      xz = size * 2 * xz_scale + xz_scale * 2
      newBlock.setAttribute('scale', `${xz} ${y_scale} ${xz}`)
      scene.appendChild(newBlock);

      newBlock = document.createElement('a-box');
      newBlock.setAttribute('class', 'collidable')
      newBlock.setAttribute('color', 'black')
      newBlock.setAttribute('position', `${t3_x} 0 ${t3_z}`)
      xz = size * 2 * xz_scale + xz_scale * 2
      newBlock.setAttribute('scale', `${xz} ${y_scale} ${xz}`)
      scene.appendChild(newBlock);

      for (let i = 0; i < size; i++) {
        //create new sphere with the attribute 'grabbableobject'
        newBlock = document.createElement('a-box');
        if (i == size -1 ) {
          newBlock.setAttribute('grabbableobject', null);
        }
        newBlock.setAttribute('class', 'collidable');
        newBlock.setAttribute('color', 'grey');
        let y = i * y_scale + y_scale
        newBlock.setAttribute('position', `${t1_x} ${y} ${t1_z} `);

        y += y_scale
        let xz = (size * 2 - i) * xz_scale
        console.log(xz)
        newBlock.setAttribute('scale', `${xz} ${y_scale} ${xz}`);
        
        console.log(newBlock)

        //append new block to the scene
        scene.appendChild(newBlock);
        console.log(scene)
      }

      
    </script>
  </body>
</html>
